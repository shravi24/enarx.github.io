"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[2685],{3905:function(e,n,t){t.d(n,{Zo:function(){return c},kt:function(){return m}});var a=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function i(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var u=a.createContext({}),s=function(e){var n=a.useContext(u),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},c=function(e){var n=s(e.components);return a.createElement(u.Provider,{value:n},e.children)},d={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},p=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,o=e.originalType,u=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),p=s(t),m=r,b=p["".concat(u,".").concat(m)]||p[m]||d[m]||o;return t?a.createElement(b,l(l({ref:n},c),{},{components:t})):a.createElement(b,l({ref:n},c))}));function m(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var o=t.length,l=new Array(o);l[0]=p;var i={};for(var u in n)hasOwnProperty.call(n,u)&&(i[u]=n[u]);i.originalType=e,i.mdxType="string"==typeof e?e:r,l[1]=i;for(var s=2;s<o;s++)l[s]=t[s];return a.createElement.apply(null,l)}return a.createElement.apply(null,t)}p.displayName="MDXCreateElement"},5085:function(e,n,t){t.r(n),t.d(n,{frontMatter:function(){return i},contentTitle:function(){return u},metadata:function(){return s},toc:function(){return c},default:function(){return p}});var a=t(7462),r=t(3366),o=(t(7294),t(3905)),l=["components"],i={},u="Running Enarx",s={unversionedId:"Installation/Wasm",id:"Installation/Wasm",title:"Running Enarx",description:"Build and run a WebAssembly module",source:"@site/docs/Installation/Wasm.md",sourceDirName:"Installation",slug:"/Installation/Wasm",permalink:"/docs/Installation/Wasm",editUrl:"https://github.com/enarx/enarx.github.io/blob/main/docs/Installation/Wasm.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Installing Enarx",permalink:"/docs/Installation/Enarx"},next:{title:"Conclusion",permalink:"/docs/Installation/Conclusion"}},c=[{value:"Build and run a WebAssembly module",id:"build-and-run-a-webassembly-module",children:[],level:2},{value:"Select a Different Backend",id:"select-a-different-backend",children:[{value:"Note about KVM backend",id:"note-about-kvm-backend",children:[],level:4}],level:2}],d={toc:c};function p(e){var n=e.components,t=(0,r.Z)(e,l);return(0,o.kt)("wrapper",(0,a.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"running-enarx"},"Running Enarx"),(0,o.kt)("h2",{id:"build-and-run-a-webassembly-module"},"Build and run a WebAssembly module"),(0,o.kt)("p",null,"Install the WebAssembly Rust toolchain:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"$ rustup target install wasm32-wasi\n")),(0,o.kt)("p",null,"Create a simple Rust program.  First make sure you're not in the repository you already created:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"$ cd ~/\n$ cargo init --bin hello-world\n$ cd hello-world\n$ echo 'fn main() { println!(\"Hello, Enarx!\"); }' > src/main.rs\n$ cargo build --release --target=wasm32-wasi\n")),(0,o.kt)("p",null,"Assuming you did install the ",(0,o.kt)("inlineCode",{parentName:"p"},"enarx")," binary and have it in your ",(0,o.kt)("inlineCode",{parentName:"p"},"$PATH"),", you can\nnow run the WebAssembly program in an Enarx keep."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"$ enarx run target/wasm32-wasi/release/hello-world.wasm\n[\u2026]\nHello, Enarx!\n")),(0,o.kt)("p",null,"If you want to suppress the debug output, add ",(0,o.kt)("inlineCode",{parentName:"p"},"2>/dev/null"),"."),(0,o.kt)("h2",{id:"select-a-different-backend"},"Select a Different Backend"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"enarx")," will probe the machine it is running on in an attempt to deduce an\nappropriate deployment backend. To see what backends are supported on your\nsystem, run:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"$ enarx info\n")),(0,o.kt)("p",null,"You can manually select a backend with the ",(0,o.kt)("inlineCode",{parentName:"p"},"--backend")," option, or by\nsetting the ",(0,o.kt)("inlineCode",{parentName:"p"},"ENARX_BACKEND")," environment variable:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"$ enarx run --backend=sgx target/wasm32-wasi/release/hello-world.wasm\n$ ENARX_BACKEND=sgx enarx run target/wasm32-wasi/release/hello-world.wasm\n")),(0,o.kt)("h4",{id:"note-about-kvm-backend"},"Note about KVM backend"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"enarx")," will look for the kvm driver loaded by the kernel and will be ready to use if it's found. Linux kernel\nautomatically loads the kvm module if the virtualization feature is enabled by the hardware. The status of whether or not\nenarx was able to find the driver can be checked with the command ",(0,o.kt)("inlineCode",{parentName:"p"},"enarx info"),". If the output shows the driver for kvm is available, you are ready to use enarx using kvm backend."),(0,o.kt)("p",null,"When you execute the ",(0,o.kt)("inlineCode",{parentName:"p"},"enarx run")," command, enarx tries to automatically select the appropriate driver, and kvm is automatically selected if it's the only backend available. But if you want to specifically use the kvm backend you can pass the ",(0,o.kt)("inlineCode",{parentName:"p"},"kvm")," as a parameter to ",(0,o.kt)("inlineCode",{parentName:"p"},"--backend")," option, or set the ",(0,o.kt)("inlineCode",{parentName:"p"},"ENARX_BACKEND")," environment variable as ",(0,o.kt)("inlineCode",{parentName:"p"},"kvm"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"$ enarx run --backend=kvm target/wasm32-wasi/release/hello-world.wasm\n$ ENARX_BACKEND=kvm enarx run target/wasm32-wasi/release/hello-world.wasm\n")))}p.isMDXComponent=!0}}]);